# -*- coding: utf-8 -*-
"""012_015_427_444

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kz9wsmfA89qsV_kgfzOxEbTF7vy_mOCn

## UE19CS345 : Network Analysis and Mining

1.   PES1UG19CS012 : Abhijit Sethi
2.   PES1UG19CS015 : Abhijnya Bhat
3.   PES1UG19CS427 : Sammith S Bharadwaj
4.   PES1UG19CS444 : Shamath K M

## Importing Libraries
"""

import nltk
import pandas as pd
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
from nltk.tokenize import sent_tokenize
from operator import itemgetter
import community
import community.community_louvain as community_louvain
# import pygraphviz

nltk.download('stopwords')

"""## Load data file from drive"""

# from google.colab import drive
# drive.mount('/content/drive',force_remount=True)

# Reading "Death on the Nile" novel text file
with open('./Nile.txt', 'r') as file:
    Nile = file.read()

"""## Preprocessing"""

Nile = ''.join([i for i in Nile if not i.isdigit()])

# Changing different charecters name to uniform names.
Nile=Nile.lower()
Nile = Nile.replace('\n\n', '\n')
Nile = Nile.replace('hercule poirot', 'hercule_poirot')
Nile = Nile.replace('hercule ', 'hercule_poirot')
Nile = Nile.replace(' poirot', 'hercule_poirot')

Nile = Nile.replace('linnet doyle', 'linnet')
Nile = Nile.replace('linnet ridgeway', 'linnet')
Nile = Nile.replace('madame linnet', 'linnet')

Nile = Nile.replace('simon doyle ', 'simon')
Nile = Nile.replace('mr doyle ', 'simon')

Nile = Nile.replace('colonel race ', 'race')
Nile = Nile.replace('colonel', 'race')

Nile = Nile.replace('andrew pennington', 'pennington')
Nile = Nile.replace('andrew', 'pennington')

Nile = Nile.replace('salome otterbourne', 'salome')
Nile = Nile.replace('mrs otterbourne', 'salome')

Nile = Nile.replace('rosalie otterbourne', 'rosalie')

Nile = Nile.replace('mrs allerton', 'mrs_allerton')

Nile = Nile.replace('tim allerton', 'tim')

Nile = Nile.replace('miss van schuyler', 'schuyler')
Nile = Nile.replace('van schuyler', 'schuyler')

Nile = Nile.replace('cornelia robson', 'cornelia')
Nile = Nile.replace('robson', 'cornelia')

Nile = Nile.replace('lord dawlish', 'ferguson')

Nile = Nile.replace('signor richetti', 'richetti')
Nile = Nile.replace('signor', 'richetti')


Nile = Nile.replace('louise bourget', 'louise')
Nile = Nile.replace('bourget', 'louise')

Nile = Nile.replace('james fanthorp', 'fanthorp')
Nile = Nile.replace('james', 'fanthorp')

Nile = Nile.replace('joanna southwood', 'joanna')
Nile = Nile.replace('southwood', 'joanna')
Nile = Nile.replace('jackie', 'jacqueline')

Nile = Nile.replace('sterndale rockford', 'rockford')

nltk.download('punkt')
sentences = sent_tokenize(Nile)

"""# Implementation

## Task (a)
### Making a list of characters from the novel "Death on the Nile"
"""

characters=['hercule_poirot','jacqueline','linnet', 'simon', 'race', 'pennington', 'salome', 'rosalie', 'mrs_allerton', 'tim', 'schuyler', 'ferguson', 'richetti', 'cornelia', 'bowers', 'louise', 'fanthorp', 'joanna', 'fleetwood','rockford']

"""## Task (b)

### Matrix implementation of social graph
"""

char_df = pd.DataFrame(0, index=characters, columns=characters)
for sentence in sentences:
    for char1 in characters:
        for char2 in characters:
            if (char1 != char2) and char1 in sentence and char2 in sentence:
                char_df[char1][char2] += 1
                char_df[char2][char1] += 1

char_df.head()

"""### Graph plot"""

G = nx.Graph()
G = nx.from_pandas_adjacency(char_df)

print("Number of nodes in the graph:", len(G.nodes()))
print("Nodes:", G.nodes())
print()
print("Number of edges in the graph:", len(G.edges()))
print("Edges:", G.edges(data=True))

plt.figure(3, figsize=(12,12))
pos = nx.fruchterman_reingold_layout(G)

nx.draw_networkx(G, pos=pos, node_size = 800, font_size=8, node_color="lightgreen")
nx.draw_networkx_edges(G, pos=pos)
edge_labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos=pos, edge_labels=edge_labels)
plt.show()

"""## Task (c)

Main Protagonists : Hercule Poirot, Linnet, Simon, Jacqueline

### Degree centrality
"""

degc = nx.degree_centrality(G)
print('Hercule Poirot : ', degc['hercule_poirot'])
print('Linnet : ', degc['linnet'])
print('Simon : ', degc['simon'])
print('Jacqueline : ', degc['jacqueline'])

degc = nx.degree_centrality(G)
# Degree Centrality for all characters
sorted(degc.items(), key=itemgetter(1), reverse=True)

"""### Betweenness centrality"""

bet = nx.betweenness_centrality(G)
print('Hercule Poirot : ', bet['hercule_poirot'])
print('Linnet : ', bet['linnet'])
print('Simon : ', bet['simon'])
print('Jacqueline : ', bet['jacqueline'])

bet = nx.betweenness_centrality(G)
# Betweenness Centrality for all characters
sorted(bet.items(), key=itemgetter(1), reverse=True)

"""### Closeness centrality"""

clos = nx.closeness_centrality(G)
print('Hercule Poirot : ', clos['hercule_poirot'])
print('Linnet : ', clos['linnet'])
print('Simon : ', clos['simon'])
print('Jacqueline : ', clos['jacqueline'])

clos = nx.closeness_centrality(G)
# Closeness Centrality for all characters
sorted(clos.items(), key=itemgetter(1), reverse=True)

"""### Pagerank centrality"""

pgr=nx.pagerank(G)
print('Hercule Poirot : ', pgr['hercule_poirot'])
print('Linnet : ', pgr['linnet'])
print('Simon : ', pgr['simon'])
print('Jacqueline : ', pgr['jacqueline'])

from operator import itemgetter
s='\n sorted pagerank:\n'
print (s)
pgr=nx.pagerank(G)
print (sorted(pgr.items(), key=itemgetter(1), reverse=True))

print(nx.transitivity(G))

nx.draw_networkx(G,node_color='cyan')

"""## Task (d)

### Clustering coefficient
"""

print(nx.clustering(G))

print(nx.clustering(G, ['hercule_poirot']))
print(nx.clustering(G, ['simon']))
print(nx.clustering(G, ['linnet']))
print(nx.clustering(G, ['jacqueline']))

#local clustering needs to be done
sorted(nx.clustering(G).items(), key = itemgetter(1), reverse = True)

print(nx.average_clustering(G))

"""### Detect communities"""

nx.draw_networkx(G,with_labels=True, node_size=100,node_color='cyan')

from networkx.algorithms.community.centrality import girvan_newman
communities_generator = girvan_newman(G)
top_level_communities = next(communities_generator)
next_level_communities = next(communities_generator)
sorted(map(sorted, next_level_communities))

"""### *Louvian* method"""

plt.figure(3, figsize=(10,10))
pos = nx.fruchterman_reingold_layout(G)

nx.draw_networkx(G, pos=pos, node_size = 800, font_size=8, node_color="cyan")
nx.draw_networkx_edges(G, pos=pos)
plt.show()

part = community_louvain.best_partition(G)
part

communities = {}
for item in part.keys():
  if part[item] == 0:
    if 0 not in communities.keys():
      communities[0] = []
    communities[0].append(item)
  elif part[item] == 1:
    if 1 not in communities.keys():
      communities[1] = []
    communities[1].append(item)
  elif part[item] == 2:
    if 2 not in communities.keys():
      communities[2] = []
    communities[2].append(item)

print('Community 1 :', communities[0])
print('Community 2 :', communities[1])
print('Community 3 :', communities[2])

community_louvain.modularity(part, G)

induced = community_louvain.induced_graph(part, G)
print(induced.nodes())
print(induced.edges())

nx.draw_networkx(induced,node_color='cyan')

list(nx.find_cliques(G))

from networkx.algorithms.community import k_clique_communities
c = list(k_clique_communities(G, 7))
print(c)

"""For k value varying from 2 to 7 the number of k clique communities obtained is 1. This aligns with the storyline as the story is set up in the cruise, all the charecters interact with each other forming single community.

## Task (e)

### Degree distribution
"""

N,K = G.order(), G.size()
avg_deg = float(K)/N
print ("Nodes: ", N)
print ("Edges: ", K)
print ("Average degree: ", avg_deg)

import collections

degree_sequence = sorted([d for n, d in G.degree()], reverse=True)  # degree sequence
# print "Degree sequence", degree_sequence
degreeCount = collections.Counter(degree_sequence)
deg, cnt = zip(*degreeCount.items())

fig, ax = plt.subplots()
plt.bar(deg, cnt, width=0.80, color='b')

plt.title("Degree Histogram")
plt.ylabel("Count")
plt.xlabel("Degree")
ax.set_xticks([d + 0.4 for d in deg])
ax.set_xticklabels(deg)

# draw graph in inset
plt.axes([0.4, 0.4, 0.5, 0.5])
A = (G.subgraph(c) for c in nx.connected_components(G))
Gcc = sorted(A, key=len, reverse=True)[0]
pos = nx.spring_layout(G)
plt.axis('off')
nx.draw_networkx_nodes(G, pos, node_size=20)
nx.draw_networkx_edges(G, pos, alpha=0.4)

plt.show()

########################################################################
# Degree distribution 
########################################################################

degrees = G.degree()
degree_sequence = sorted([d for n, d in G.degree()], reverse=True)  # degree sequence

plt.loglog(range(1,G.order()+1),degree_sequence,'k.')
plt.title("Degree distribution with log scale")
plt.xlabel('Rank')
plt.ylabel('Degree')
plt.ylim(1,max(degree_sequence)+1)
plt.xlim(.9,10001)
plt.savefig("degree_distribution.png")

print(nx.average_shortest_path_length(G))

a = nx.is_connected(G)
s='\n Is a connected graph: ' +repr(a)
print (s)

no=len(list(nx.connected_components(G)))
s='\n no of connected components: ' +repr(no)
print (s)

#Gecum13ate a sorted list of connected components, largest first 
CoC=sorted(nx.connected_components(G), key = len, reverse=True)
for item in CoC:
    cclen=len(item)
    s= "\n Connected component length:" +repr(cclen)
    print (s)
    print ("\n Connected component :")
    print (item)

giant = max(nx.connected_components(G), key=len)

giant

len(giant)

"""### Ego network"""

s='hercule_poirot'
hub_ego=nx.ego_graph(G,s)

# Draw graph
pos=nx.spring_layout(hub_ego)
nx.draw(hub_ego,pos,node_color='b',node_size=50,with_labels=False)

# Draw ego as large and red
plt.savefig('hercule.png')
plt.show()
nx.write_gml(hub_ego,"egonw_hercule.gml")

no_node=len(hub_ego.nodes())
no_edges=len(hub_ego.edges())
print("hercule's Ego Network : nodes", no_node)
print("hercule's Ego Network : edges", no_edges)

"""### Comparision with random graph model"""

nodes=G.number_of_nodes()
nodes

#calculate average degree to use with random graph models 
degree_list = list(nx.degree(G))
no_nodes=len(degree_list)
total_degree=0
for node in degree_list[:19]:
    print("Node ", node[0], " : Degree is ", node[1])
    total_degree=total_degree+ node[1]
avg_degree= total_degree/no_nodes
avg_degree

p=avg_degree/(no_nodes-1)
#G2 = nx.erdos_renyi_graph(no_nodes,p)  # same call 
G2 = nx.gnp_random_graph(no_nodes,p)
fig = plt.figure(figsize =(10 ,10))
nx.draw(G2, with_labels = False, node_size = 20, linewidths = 0.5, width = 0.5, arrows=True)
plt.show()

#Make random graph 
G2 = nx.gnp_random_graph(no_nodes,0.1)
#assuming probability for node creation 0.1 
fig = plt.figure(figsize =(10 ,10))
nx.draw(G2, with_labels = False, node_size = 20, linewidths = 0.5, width = 0.5, arrows=True)
plt.show()

neighbours=5
H = nx.barabasi_albert_graph(no_nodes,neighbours)
fig = plt.figure(figsize =(10 ,10))
nx.draw(H, with_labels = False, node_size = 20, linewidths = 0.5, width = 0.5,arrows=True)
plt.show()

H = nx.newman_watts_strogatz_graph(no_nodes,neighbours,p)
fig = plt.figure(figsize =(10 ,10))

nx.draw(H, with_labels = False, node_size = 20, linewidths = 0.5, width = 0.5,arrows=True)
plt.show()

characters=['hercule_poirot','jacqueline','linnet', 'simon', 'race', 'pennington', 'salome',
            'rosalie', 'mrs_allerton', 'tim', 'schuyler', 'ferguson', 'richetti', 'cornelia', 'bowers', 'louise', 'fanthorp', 'joanna', 'fleetwood','rockford']

"""## Analysis

### Finding protagonists
"""

import matplotlib.pyplot as plt
  
# create data
x=['hercule_poirot','tim','linnet','pennington','schuyler','jacqueline','simon']
y1=[0.947, 0.894, 0.789, 0.789, 0.789, 0.684, 0.631]
y2=[0.057, 0.037, 0.069, 0.061, 0.026, 0.018, 0.0103]
y3=[0.95, 0.90, 0.82, 0.82, 0.82, 0.76, 0.730]
y4=[0.111,0.098,0.089,0.051, 0.0437 , 0.079, 0.077]
  
# plot bars in stack manner
plt.bar(x, y1, color='r')
plt.bar(x, y2, bottom=y1, color='b')
plt.bar(x, y3, bottom=y1, color='m')
plt.bar(x, y4, bottom=y1, color='g')

plt.show()

"""We took the main characters from the novel and plotted their centralities in the stacked bar chart as shown.
In the story the main characters are:
 <br />
 <br />Hercule Poirot is the detective, Linnet is the character who gets murdered, Simon and Jacqueline are the main antagonists, and Tim hatches a plan to steal Linenet's expensive pearls.
  <br />
 <br />From the graph we see that Hercule Poirot, Tim and Linnet are the top three which aligns with our story, and Simon and Jacqueline fall a little lower.  <br />This is expected as the protagonists are mentioned much more regularly that the antagonists

As all the centralities
"""

#Applying shortest path to find the protagonist
import random
def plot_paths(G, paths):
    color=["red","orange","yellow"]
    plt.figure(figsize=(12,12))
    pos = nx.fruchterman_reingold_layout(G)
    nx.draw_networkx_nodes(G, pos=pos, node_size=1000, node_color='lime')
    nx.draw_networkx_labels(G, pos=pos, labels={n: n for n in G})
    nx.draw_networkx_edges(G, pos=pos)
    for l1 in paths:
      for path in l1:
          edges = list(zip(path, path[1:]))
          nx.draw_networkx_edges(G, pos=pos, edgelist=edges, edge_color=color[random.randint(0,2)], width=3)
    ax = plt.gca()
    ax.set_axis_off()
    ax.grid(None)

target = 'simon'
char_list=[]
for i in range(20):
  for j in range (20):
    source = characters[i]
    target= characters[j]
    char_list.append(nx.shortest_path(G, source, target))
char_list=[[x] for x in char_list if len(x)>2]
plot_paths(G,char_list)

"""This graph shows the shortest path through between each character with path length greater than 1.
<br/>Through this analysis we can see that the node of Hercule Poirot is the busiest, making him the main protagonist, which is true according to the book.

Components in graph, graph extracted is a single component connected graph

What do the clustering coefficients, discovered communities, extracted ego network 
of protagonists and average shortest path tell you about the dynamics in the story ?
"""

nx.is_connected(G)

plt.figure(3, figsize=(12,12))
pos = nx.fruchterman_reingold_layout(G)

nx.draw_networkx(G, pos=pos, node_size = 800, font_size=8, node_color="orange")
nx.draw_networkx_edges(G, pos=pos)
edge_labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos=pos, edge_labels=edge_labels)
plt.show()

"""Upon analysing we can see that the graph is a single component, connected graph and it makes sense because the whole sequence of story happened in a cruise where every character came across every other character. So the shortest path between all the characters is a maximum of 2.

### Dynamics of the story

#### From clustering coefficients
"""

print(nx.clustering(G, ['hercule_poirot']))
print(nx.clustering(G, ['simon']))
print(nx.clustering(G, ['linnet']))
print(nx.clustering(G, ['jacqueline']))

"""The local clustering coefficient of Hercule Poirot is very low.
This suggests that he is a very influential and important character of the novel.
Linnet also has a very low clustering coefficient. This also aligns with story as

#### Discovered Communities
"""

print('Community 1 :', communities[0])
print('Community 2 :', communities[1])
print('Community 3 :', communities[2])

"""From the Lovian community, the following communities are generated:

Rosalie is Mrs Allerton's daughter. Tim is Rosalie's lover. Tim and Joanna plot a plan to steal Linnet's Pearl. So it makes sence for them to be in the same community.

Hercule Poirot and Race are in the same community. Since they are very close friends this aligns with the dynamics of the story.

Linnet and Simon are married to one another. Jacqueline is Linnet's close friend and Simon's lover. So according to the graph and the story, they have to be in the same community.

#### Average shortest path
"""

nx.average_shortest_path_length(G)

"""This shows that the characters chosen have a good amount of communication and the weights in the graph as we saw in the visualisation and it suggests that hercule had the most interaction which again supports that he is the protogonist in that novel.
Another reason for this is that Hercule Poirot in the book interviews every individual. Hence the shortest path between two people is atmost 2 hops.

#### Ego network of Protagonist
"""

s='hercule_poirot'
hub_ego=nx.ego_graph(G,s)

# Draw graph
pos=nx.spring_layout(hub_ego)
nx.draw(hub_ego,pos,node_color='b',node_size=50,with_labels=False)

# Draw ego as large and red
plt.savefig('hercule.png')
plt.show()
nx.write_gml(hub_ego,"egonw_hercule.gml")

"""Centrality"""

pos = nx.spring_layout(G, seed=800)
nx.draw_networkx(G, pos, nx.degree_centrality(G), 'Degree Centrality')
nx.draw_networkx(G, pos=pos, node_size = 600, font_size=8, node_color="blue")
edges = nx.draw_networkx_edges(G, pos)

nx.draw_networkx(G, pos, nx.closeness_centrality(G), 'Closeness Centrality')
nx.draw_networkx(G, pos=pos, node_size = 600, font_size=8, node_color="lightgreen")

nx.draw_networkx(G, pos, nx.betweenness_centrality(G), 'Betweenness Centrality')
nx.draw_networkx(G, pos=pos, node_size = 350, font_size=8, node_color="red")

def page_rank(G, d=0.85, tol=1e-2, max_iter=100):
    
    nodes = G.nodes()
    matrix = nx.adjacency_matrix(G, nodelist=nodes)
    out_degree = matrix.sum(axis=0)
    weight = matrix / out_degree
    N = G.number_of_nodes()
    pr = np.ones(N).reshape(N, 1) * 1./N

    # need to repeat the initial step twice
    # for matplotlib animation
    yield nodes, pr, "init"
    yield nodes, pr, "init"

    for it in range(max_iter):
        old_pr = pr[:]
        pr = d * weight.dot(pr) + (1-d)/N
        yield nodes, pr, it
        err = np.absolute(pr - old_pr).sum()
        if err < tol:
            return pr

from matplotlib.animation import FuncAnimation
def update(r):
    res_nodes, res_values, it = r
    res_values = np.asarray(res_values).ravel()
    plt_nodes = nx.draw_networkx_nodes(
        G, pos,
        ax=ax,
        nodelist=res_nodes,
        node_color=res_values,
        alpha=1,
        node_size=600,
        cmap=plt.cm.Blues,
        vmin=0,
        vmax=0.2
    )
    ax.axis("off")
    ax.set_title(f"Iteration {it}")
    nx.draw_networkx_edges(G, pos)
    nx.draw_networkx_labels(G, pos, font_size=14)
    return [plt_nodes, ]




pos = nx.kamada_kawai_layout(G)

f, ax = plt.subplots()
ani = FuncAnimation(
    f,
    update,
    frames=page_rank(G),
    interval=1000,
    blit=True
)
f.suptitle(f"  Page Rank")
ani.save("graph_pr.gif", writer='pillow')

"""### Comparison of different graph models v/s our social graph"""

p=avg_degree/(no_nodes-1)
#G2 = nx.erdos_renyi_graph(no_nodes,p)  # same call 
G2 = nx.gnp_random_graph(no_nodes,p,seed = 12)
fig = plt.figure(figsize =(10 ,10))
nx.draw(G2, with_labels = False, node_size = 21, linewidths = 0.5, width = 0.5, arrows=True)
plt.show()

print("Number of connected components in graph : ",nx.number_connected_components(G2))
print("Number of edges : ",nx.number_of_edges(G2))

"""The random generated graph has 1 component -- similar to our social graph.

The average shortest path is a decent approximation of our social graph.
"""

#Make random graph 
G2 = nx.gnp_random_graph(no_nodes,0.1)
#assuming probability for node creation 0.1 
fig = plt.figure(figsize =(10 ,10))
nx.draw(G2, with_labels = False, node_size = 21, linewidths = 0.5, width = 0.5, arrows=True)
plt.show()

print("Number of connected components in graph : ",nx.number_connected_components(G2))
print("Number of edges : ",nx.number_of_edges(G2))

"""Here there are 7 connected components, this does not simulate the social graph we obtained."""

neighbours=7
H = nx.barabasi_albert_graph(no_nodes,neighbours, seed=42)
fig = plt.figure(figsize =(10 ,10))
nx.draw(H, with_labels = False, node_size = 21, linewidths = 0.5, width = 0.5,arrows=True)
plt.show()

"""Taking neighbours as 7, the connected components and average shortest paths, we get a good approximation of our social graph.

Decreasing neighbours seems to increase the average shortest path - as expected. 
"""

print("Number of connected components in graph : ",nx.number_connected_components(H))
print("Number of edges : ",nx.number_of_edges(H))
print("Average Shortest Path Length : ",nx.average_shortest_path_length(H))

"""The random generated graph has 1 component component similar to our social graph.

The average shortest path from the random graph is close to the value in our social graph. Therefore, the generated graph is a good approximation.

### Visualizing communities

#### K-clique

Note: Remove this part
"""

for i in range(2,8):
  c = list(k_clique_communities(G, 7))
  if len(c)>1:
    print("More than one clique found")
    break
print("Only one clique found for k ranging from 2-7")

"""The above piece of code checks for cliques ranging from k values of 2 to 7.
As seen from the output there exists only one clique. 
This aligns with the storyline as all the characters interact with each other as the entire novel takes place in a cruise ship, making the shortest path betweek an two characters a mazimun of two if not one
"""